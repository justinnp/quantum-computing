from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile, transpiler
from utils import get_benchmark_dict
import numpy as np

workload_list = get_benchmark_dict("SWAP_Benchmarks")

def create_coupling_maps():
    """
    Generate each coupling map as shown above using transpiler.CouplingMap and store them in the dictionary provided using the given keys.

    Args: 
        None
    Return:
        output_dict: dict[str, qiskit.transpiler.CouplingMap]
    """

    coupling_maps = {}
    coupling_maps['GRID 5X5'] = None
    coupling_maps['GRID 5X4'] = None
    coupling_maps['GRID 7X3'] = None
    coupling_maps['RING 20'] = None
    ############################################################################
    # Student code begin
    ############################################################################
    for grid in [(5, 5, 'GRID 5X5'), (5, 4, 'GRID 5X4'), (7, 3, 'GRID 7X3')]:
        height = grid[0]
        width = grid[1]
        grid_edges = []
        # starting from maximum qubit number
        # connect horizontal edges
        for row in range(height):
            for col in range(width - 1):
                qubit = row * width + col
                grid_edges.append([qubit, qubit + 1])
                grid_edges.append([qubit + 1, qubit])
        # connect vertical edges
        for col in range(width):
            for row in range(height - 1):
                qubit = row * width + col
                grid_edges.append([qubit, (row + 1) * width + col])
                # qiskit requires stating direction, so duplicating in the opposite direction for symmetric grids
                grid_edges.append([(row + 1) * width + col, qubit])
        c_map = transpiler.CouplingMap(couplinglist=grid_edges)
        print(grid_edges)
        coupling_maps[grid[2]] = c_map
    
    ring_edges = []
    for i in range(20):
        neighbor_forward = (i + 1) % 20
        # negative modulo: n - a mod n
        neighbor_backward = (i - 1) % 20
        ring_edges.append([i, neighbor_forward])
        ring_edges.append([i, neighbor_backward])
    c_map = transpiler.CouplingMap(couplinglist=ring_edges)
    coupling_maps["RING 20"] = c_map

    ############################################################################
    # Student code end
    ############################################################################

    return coupling_maps


def average_depth_change():
    """
    calculate the average change of circuit depth when transpiling the benchmark circuits for given coupling maps,
    using SABRE for routing and mapping. You need to return a dictionary with benchmark circuits' names as keys and
    change of circuit depth averaged over all coupling maps.
    
    You are expected to use the same names of circuits generated by `get_benchmark_dict`.
    
    Args: 
        None
    Return:
        output_dict: dict[str, float]
    """

    output_dict = {}
    ############################################################################
    # Student code begin
    ############################################################################
    coupling_maps = create_coupling_maps()
    # The mean of the depth differences (mean(sabre-basic))

    raise NotImplementedError(
            "`average_depth_change` function in "
            + "`question2.py` needs to be implemented"
        )
    
    ############################################################################
    # Student code end
    ############################################################################
    
    return output_dict


def average_nswap_change():
    """
    Calculate the average number of swaps inserted when transpiling the benchmark circuits for given coupling maps,
    using SABRE for routing and mapping. You need to return a dictionary with benchmark circuits' names as keys and
    number of swaps inserted averaged over all coupling maps.

    You are expected to use the same names of circuits generated by `get_benchmark_dict`.
    
    Args: 
        None
    Return:
        output_dict: dict[str, float]
    """

    output_dict = {}
    ############################################################################
    # Student code begin
    ############################################################################

    raise NotImplementedError(
            "`average_nswap_change` function in "
            + "`question2.py` needs to be implemented"
        )
    
    ############################################################################
    # Student code end
    ############################################################################

    return output_dict
